1
00:00:00,909 --> 00:00:05,056
Bem-vindo a série de vídeos sobre programação funcional em Kotlin com Arrow

2
00:00:05,081 --> 00:00:10,786
Arrow é uma biblioteca que contém `datatypes` e `typeclasses` e que permite uma tipagem estilo "funcional" em Kotlin

3
00:00:10,818 --> 00:00:15,521
Nesse vídeo, aprenderemos sobre o `datatype` `Either` e para o quê é usado

4
00:00:15,554 --> 00:00:22,906
[Música]

5
00:00:23,070 --> 00:00:28,189
`Either` é um `datatype` em Arrow usado para modelar funções que podem retornar mais de um valor,

6
00:00:28,860 --> 00:00:30,860
seja um valor ou outro

7
00:00:33,090 --> 00:00:36,187
`Either` é frequentemente modelado como um tipo algébrico (ADT)

8
00:00:36,212 --> 00:00:40,064
Da mesma forma que vimos o `Option`, o `Either` tem muitos casos

9
00:00:40,590 --> 00:00:43,639
Em Kotlin, tipos algébricos (ADT) são modelados com classes seladas (sealed classes)

10
00:00:45,570 --> 00:00:49,009
`Either` tem dois possíveis valores: `Left` ou `Right`

11
00:00:49,680 --> 00:00:53,102
O lado esquerdo normalmente é usado como caso excepcional

12
00:00:53,127 --> 00:00:56,683
No lado direito, normalmente o "caminho feliz" (happy path)

13
00:00:57,378 --> 00:01:01,037
Isto é importante porque o lado direito do `Either` tende a ser mais utilizado,

14
00:01:01,077 --> 00:01:03,767
em especial por funções como: 'map()', 'filter()' e 'flatMap()',

15
00:01:03,807 --> 00:01:05,854
que operam apenas no caso de `Right`

16
00:01:06,810 --> 00:01:09,140
Existem dois construtores que trabalham em conjunto ao `Either`

17
00:01:09,510 --> 00:01:14,959
O construtor `Right` permite levar valores ao `Either`, colocando-os do lado direito

18
00:01:16,080 --> 00:01:18,845
Enquanto que o construtor `Left` coloca os valores do lado esquerdo

19
00:01:19,418 --> 00:01:26,206
Como podemos ver, modelamos um `KnownError` sem usar `Exception` e colocando-o no lado esquerdo,

20
00:01:26,250 --> 00:01:30,739
porque o processamento vai ocorrer com o `Int`, que está do lado direito

21
00:01:32,039 --> 00:01:34,752
Arrow fornece extensões de sintaxe para o `Either`

22
00:01:34,777 --> 00:01:39,007
Podemos facilmente colocar valores `Right` e `Left`,

23
00:01:39,078 --> 00:01:43,309
desde que na declaração seja fornecido o tipo do outro caso

24
00:01:44,249 --> 00:01:50,839
Pode-se transformar o conteúdo do `Either` com uma variedade de funções, como: 'fold()', 'getOrElse()', 'map()' e 'flatMap()'

25
00:01:51,509 --> 00:01:53,843
Isto pode soar familiar para você,

26
00:01:53,891 --> 00:01:57,090
Porque já vimos estas mesmas funções em `Option`

27
00:01:57,115 --> 00:02:00,342
Isso é parte do modelo de programação unificada do Arrow

28
00:02:00,869 --> 00:02:05,538
Pegamos todos os combinadores funcionais e tentamos aplicar ao maior número possível de `datatypes`,

29
00:02:05,639 --> 00:02:07,789
então a maior parte compartilhará a mesma API

30
00:02:09,146 --> 00:02:13,011
Podemos extrair valores internos do `Either` usando expressões 'when' do Kotlin

31
00:02:13,641 --> 00:02:20,396
Nesse caso, o valor resultante Either<KnownError, Int> pode ser utilizado em expressões 'when',

32
00:02:20,421 --> 00:02:26,313
sendo que seu resultado será um dos possíveis casos, `Left` ou `Right`

33
00:02:27,230 --> 00:02:30,913
Uma forma mais fácil de lidar com isto é usando o 'fold()'

34
00:02:30,938 --> 00:02:33,664
'fold()' permite passar duas funções

35
00:02:34,640 --> 00:02:37,000
A primeira função cobre o caso `Left`

36
00:02:37,849 --> 00:02:41,469
Neste caso, se encontrarmos um `KnownError`, devemos retornar zero

37
00:02:42,080 --> 00:02:45,253
O segundo argumento é uma função que cobre o caso `Right`

38
00:02:45,443 --> 00:02:48,964
Neste caso, temos a chance de transformar o conteúdo de `Right`

39
00:02:49,774 --> 00:02:52,721
Uma derivação do 'fold()' é o 'getOrElse()'

40
00:02:52,750 --> 00:02:57,704
Em 'getOrElse()', fornecemos apenas a função que cobre o caso `Left`

41
00:02:57,729 --> 00:03:01,263
Neste caso, se encontrarmos um `KnownError`, devemos retornar zero

42
00:03:02,510 --> 00:03:05,680
'map()' nos permite transformar o valores internos do `Either`

43
00:03:05,728 --> 00:03:11,003
Ele opera apenas no `Right` e por isso dizemos que o `Either` tende a direita, ou melhor, `Right`

44
00:03:11,989 --> 00:03:19,389
Se usarmos 'map()' e encontrarmos um `Left`, então a transformação não é aplicada e o `Left` é retornado sem qualquer alteração

45
00:03:20,299 --> 00:03:22,509
Se tivermos múltiplos valores `Either`

46
00:03:22,510 --> 00:03:25,542
e queremos processá-los sequencialmente em caso de `Right`,

47
00:03:25,567 --> 00:03:26,844
nós usamos `flatMap()`

48
00:03:27,098 --> 00:03:30,344
'flatMap()', assim como o 'map()', é aplicado ao `Right`

49
00:03:31,370 --> 00:03:34,299
Ao invés de lidar com múltiplos 'flatMap()' aninhados,

50
00:03:34,324 --> 00:03:38,224
Uma solução mais simples é usar o `Either` como 'monad comprehensions'

51
00:03:38,690 --> 00:03:44,709
A mônada `Either` nos permite receber os resultados e então retorná-los como um `Right`

52
00:03:45,410 --> 00:03:53,049
Com todos os valores acessíveis, podemos somá-los ou aplicar qualquer outra transformção em um estilo imperativo

53
00:03:54,630 --> 00:03:58,430
'bind()' é uma função suspensa do sistema de coroutines (corotinas) do Kotlin

54
00:03:58,710 --> 00:04:02,594
Ao invocamos o 'bind()', delegamos a sequência de chamadas para o 'flatMap()'

55
00:04:02,619 --> 00:04:08,750
Dessa forma, evitamos 'flatMap()' aninhados e ainda processamos os resultados do `Either` de uma maneira imperativa

56
00:04:11,100 --> 00:04:13,505
Se usamos 'bind()' em um valor `Left`,

57
00:04:13,530 --> 00:04:16,664
o processamento vai saltar e retornar o `Left`

58
00:04:17,910 --> 00:04:23,339
Podemos usar o construtor 'applicative' para processar diferentes valores de `Either` que são independentes entre si

59
00:04:23,364 --> 00:04:27,854
Com esse construtor, podemos usar 'map()' ou converter em tuplas um conjunto de operações,

60
00:04:28,110 --> 00:04:31,249
preservando o tipo e a aridade

61
00:04:32,640 --> 00:04:40,009
Assim como nas 'monad comprehensions' se encontrarmos um `Left`, então saltaremos e retornaremos um `Left` do tipo `KnownError`

62
00:04:40,860 --> 00:04:43,217
Nesse vídeo aprendemos sobre o `Either`

63
00:04:43,242 --> 00:04:44,702
Da mesma forma que o `Option`,

64
00:04:44,727 --> 00:04:51,013
o  `Either` possui muitas das funções e funcionalidades, como: `fold()`, `map()`, `flatMap()`

65
00:04:51,690 --> 00:04:55,490
Arrow propõe um modelo unificado de programação para todos os `datatypes`,

66
00:04:55,515 --> 00:04:59,684
onde todos eles compartilham de combinadores funcionais que são normalmente expressos como `typeclasses`

67
00:05:00,060 --> 00:05:02,291
Aprenderemos mais sobre eles nos próximos vídeos

68
00:05:02,371 --> 00:05:03,449
Obrigado por assistir!

69
00:05:03,555 --> 00:05:11,547
[Música]

